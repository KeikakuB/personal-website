---
title: The Second Coming of Rust
blog: blog
date: 2020-09-20
tags: tech
---
In these UNCERTAIN TIMES, I've found myself with a little more free time because I don't have to commute to an office every day. I've tried to funnel that free time into creative and constructive hobbies. I'm not sure if I've succeeded but I'm trying my best. ¯\_(ツ)_/¯

In the past week, I've spent some time learning the Rust programming language. I've heard a lot of good things about it and I finally took the plunge. Here's a couple of notable features that I've managed to grok.

## Everything is immutable

Immutability makes code easier to reason about. Rust has the strongest implementation of immutability I've seen in a programming language.

Any variable you define is immutable by default.

~~~ rust
let x = 5;
// The next line will explode
//   gracefully at compile time
//   if uncommentted.
// x = x + 1;
~~~

Revolutionary!

If you want to have a mutable variable, you have to explicitly write it out like this.

~~~ rust
let mut x = 5;
// The next line works as expected
x = x + 1;
~~~

This is good.

Same thing goes for struct (think C or C++ structs) values, function parameters, etc.

~~~ rust
struct Counter {
    n: i32,
}
impl Counter {
    // This function CAN modify the Counter.
    pub fn increment(&mut self) {
        self.n = self.n + 1;
    }
    // This function CANNOT modify the Counter.
    pub fn value(&self) {
        self.n
    }
}
~~~

Without the `mut` keyword before a variable, you cannot modify said variable in any way; making it truly immutable. This is similar to how C++ handles its `const` keyword. Although, in Rust, having everything be immutable by default is even better.

## Null values, no more!

Handling `null` values is the bane of my existence when working with my favorite, although we'll see how long that lasts, programming language, Python. The concept of a "null value" was a mistake, it leads to problems upon problems. Don't get me started on the whole `undefined` vs `null` JavaScript debacle. What a mess...

If we can avoid it we should.

Most, if not all, functional programming languages use the concept of an option type which is a much better way of handling missing values. Rust includes some functional programming language features like the option type.

In Rust, unlike other procedural programming languages, especially object-oriented ones, the option type is not one of many ways to handle missing values, it is the ONLY way. This combined with pattern matching, as shown below, forces you to handle any potentially missing values otherwise the compiler will complain (which is good).

~~~ rust
let o: Option<i32>;
if i % 2 == 0 {
    o = None;
} else {
    o = Some(1);
}
matches o {
  Some(n) => o = Some(n + 1),
  // If the following line was missing,
  //   then the compiler would complain.
  None => o = Some(1),
}
// If 'o' is None then this would explode
let value: i32 = o.unwrap();
~~~

Having the compiler detect, and nag us about, every possible case where we might be missing a value is extremely valuable to help us write good, safe and functional code.

## Reasonable Environment and Package Manager

Cargo is the package manager of the Rust language and it does exactly what you would expect it to do. Compared to the, truly truly, awful mess that is the equivalent Python solution. I don't want to get into virtual environments, the differences between Python 2 and Python 3, pip vs. pip3, and more because even after a decade of working with Python I still don't fully understand all the intracies of how it handles, or doesn't handle if you prefer, dependencies.

Comparatively, Cargo is God's gift to the world. It is easy to understand and make use of.

A single official package and environment manager that works like it should isn't a sexy feature, I'll give you that. But a programming language that gets the boring stuff like this right allows you to focus on solving interesting problems.

How does it work? Any dependencies are specified in a Cargo.toml file like so.

~~~ toml
[package]
name = "tmer"
version = "0.1.0"
authors = ["strategineer <me@strategineer.com>"]
edition = "2018"

[dependencies]
clap = "2.33.3"
rand = "0.7.3"
log = "0.4.11"
~~~

Running the following commands in your shell from anywhere in your project directory; they'll do what you expect using the dependencies you've set up.

~~~ shell
echo "Update your dependencies."
cargo update

echo "Run your code."
echo "This will update your dependencies if needed."
cargo run

echo "Test your code."
cargo test
~~~

Need I say more?

## Traits!

Traits are interfaces possibly with default implementations that can be added to your own structs but can also be added onto existing structs in, for example, library code. They are somewhat reminiscent of mixins in object-oriented programming.

You can take a struct and add traits to it which will use the default implementations of said traits to augment the struct with various extra functionality.

~~~ rust
#[derive(Debug)]
struct Counter {
    name: String,
    n: i32,
}
~~~

The `Debug` trait added to the `Counter` struct implements a default implementation allowing us to output any instance of the struct as text for debugging purposes as shown below.

~~~ rust
fn main() {
    let c = Counter {
        name: "C1".to_string(),
        n: 20,
    };
    println!("{:?}", c);
    // OUTPUT:
    // Counter { name: "C1", n: 20 }
}
~~~

We can implement a trait ourselves in order to customize it. For example, if we would like to allow for a struct to be transformed into text a specific way (for non-debugging purposes) then we can implement the `fmt::Display` trait like so.

~~~ rust
use std::fmt;
impl fmt::Display for Counter {
    fn fmt(&self,
        f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f,
            "Counter '{}' has the value: {}",
            self.name,
            self.n)
    }
}
~~~

Notice that this is done outside of the context of the struct's definition. So, we can even implement the functionality tied to a trait as shown above for structs defined outside of our own code.

## Rusteroony Pepperoni
I hope this get you to take a look at Rust! I've been enjoying playing around with it; I'm building a command line application that randomly generates teams over multiple rounds for playing games online with friends called [tmer](https://github.com/strategineer/tmer). If you want to take a look at that or help out, feel free!

Stay safe out there.
