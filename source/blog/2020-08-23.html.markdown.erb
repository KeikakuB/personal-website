---
title: "A Gamer's Guide to: Servers"
blog: blog
date: 2020-08-23
tags: gaming
---
Welcome to my first "A Gamer's Guide toâ€¦" post. This series will cover a wide range of topics of interest to gamers from the perspective of a video game programmer.

I know a little about what goes into making a video game. I gained a wide breadth of knowledge of every part of a video game including game engines, physics, gameplay, audio, AI, C++ (shiver) and more in a post graduate program. After finishing my degree, I was hired by an independent game studio, Borealys Games, to work on Mages of Mystralia, a Zelda-like game where you find magical runes which you can combine to create your own spells. After shipping the game and working on a cancelled project, I went on to Framestore VR where we built high-end VR experiences meant to be installed in amusement parks (lol@amusement parks in 2020). I'm not working in the video game industry anymore because making games is really hard, I realized that my time was better spent elsewhere.

With that out of the way, today's topic is online multiplayer games and servers. How can you and your friends play a game together over the internet? How can a game be developed to make it harder for hackers to ruin the multiplayer experience for the other players? What's the difference between a dedicated server and a non-dedicated server? When someone says peer-to-peer what does that mean?

I will try to answer all these questions and more over the course of the next few paragraphs. Follow me on this journey, into the magical world of online multiplayer video games.

# Basics
A server usually refers to a computer or a program running on a computer with a specific role. It handles requests from other computers/programs, called clients, over a network and "serves", or responds, with data.

To understand what a server does, we need to understand what a computer does. Computers speak in zeros and ones. Anything you do on a computer is just a sequence of zeros and ones on some level. Watching Netflix? Zeros and ones. Drawing anime girls? Zeros and ones. Playing video games? Zeros and ones. You get the idea.

We build systems on top of these zeros and ones to make a computer solve problems for us. The problem we're trying to solve when designing an online multiplayer video game is, how can we allow multiple players to play with each other over the internet? Zeros and ones...

At the most basic level, we need to send zeros and ones over the internet, in some way, to ensure that all the players experience a shared game world.

This is an illusion, there's not one game world but many; one for each player in the game. A big complexity of online multiplayer games is ensuring that each player's game world is synchronized with every other player's as much as possible. When game worlds aren't are desynchronyzed due to a bad code, bad network infrastructure or malicious actors (hackers) this hurts the online multiplayer game experience and is something all game developers try to avoid.

In a single player FPS game, if I press the Right Trigger on my controller, my character shoots his gun. The game will react to my pressing of the button by playing visual effects, playing a sound and applying any sort of damage (visual or not) to the enviromnent or any enemies as appropriate. Simple right?

This becomes much more complicated in a multiplayer context. When I press the Right Trigger, the same events occur because if we had to wait for a response from the server before we saw the gun smoke, heard the sound and saw the damage caused then the game would feel very sluggish.

But, behind the scenes, the information that I shot my gun needs to be sent to all the other clients so that they can also display the gunfire, play the sounds and react to the damage caused in their own game worlds.

There is two main architectures, of which there many different variations and implementations, which are commonly used in video games to solve this problem. I will now discuss them in a digestible way. There are exceptions to everything I will write, but after reading this article you should have a good basic understanding of how the online multiplayer video games that you play, work under the hood.

I will start by explaining what a peer-to-peer architecture looks like, then I will cover the more common client-server architecture and explain why it's used in most video games these days.

# Peer-to-Peer Architecture

<% graphviz do %>
graph G {
  nodesep=1.5;

  a -- b;
  a -- c;
  a -- d;
  b -- c;
  b -- d;
  c -- d;

  { rank = same; a; b; }
  { rank = same; c; d; }


  a [label="Client 1"]
  b [label="Client 2"]
  c [label="Client 3"]
  d [label="Client 4"]
}
<% end %>

My first online gaming experiences, namely Starcraft and Halo 2, suffered from the use of a peer-to-peer architecture. If you've ever heard a seven year old child scream at his mother like so, "unplug the router, you cunt!", then you've probably played a game with a peer-to-peer architecture.

The most common form of peer-to-peer architecture is one client, acting as a "host", which acts as both a client and a server. It displays the game world graphically for the player and reacts to the player's inputs but it also communicates with all the other clients to keep their game worlds in sync.

<% graphviz do %>
graph G {

  s -- c2;
  s -- c3;
  s -- c4;

  s [label="Client/Server 1"]
  c2 [label="Client 2"]
  c3 [label="Client 3"]
  c4 [label="Client 4"]
}
<% end %>

This host-based peer-to-peer architecture can be considered to be the polar opposite of the dedicated server paradigm which we will be looking at in the next section.

A peer-to-peer architecture is usually more complex to implement than a client-server architecture, but it is usually cheaper to run over the long term because the game developer doesn't need to maintain as many (or any potentially) of their own servers. The players use their own hardware (PCs, consoles or phones) to play the game and so, in theory, this approach is infinitely scalable. More players means more servers for players to play on.

This architecture has fallen out of favour because:
- Most AAA video games have more than two players playing with each other at once, if the host player's internet connection is unstable (or if their mother plugs the internet cable out of the router) then it disturbs the experience of all other players. A notable example of this is For Honor at launch. If the host of a game quit, then all other players would have to wait for minutes to have another host be selected. Inside and outside of the company, people were rolling on the floor at this decision.
- Most AAA video games are competitive in nature, and peer-to-peer architectures inherently suffer from unfairness due to the host player having several advantages over the other players. The big one being a non-existent ping meaning that the host player can act and react faster than all the other players to the game world and the player characters within it.
- It's much harder, impossible?, to stop a host player from cheating given that they theoretically have complete control over the game world.

Peer-to-peer architectures are not used much these days but before we move on to the client-server architecture, let's dive a little deeper into the topic of cheating.

In a peer-to-peer architecture, the host player's client is fully responsible for simulating the shared game world inhabited by all the players. Thus, a malicious host player can modify their client through reverse engineering to give themselves an unfair advantage. For example, they could potentially make their character invincible, make their character invisible, allow their character to teleport or phase through walls, etc.

Of course, this is highly dependent on how the video game is made. The anti-cheat industry vs. video game hackers arms race is ever escalating. Some games have proven to quite the challenge to hack while others not so much. We've recently seen a new online competitive multiplayer FPS game put in place a very invasive anti-cheat solution into their game (a process that runs at start up of your computer and runs the whole time that it's on even if you don't play the game). It's all a part of the arms race!

Every game is built differently and so the specific kind of cheating that could occur in a game with a peer-to-peer architecture is vast. As is clear by the efficiency and popularity of GGPO, which is a peer-to-peer architecture, it is possible to create a peer-to-peer architecture that works and doesn't allow for cheating but it's quite hard. Fighting games are a special edge case considering that you usually only have two players playing with each other at a time, there's not much cheating that could occur given how most fighting games work and fighting games aren't popular enough to warrant the work you would need to put into making cheats for them.

Now we'll take a look at the much more common network architecture, the client-server architecture.

# Client-Server Architecture

<% graphviz do %>
graph G {

  s -- c1;
  s -- c2;
  s -- c3;

  s [label="Server"]
  c1 [label="Client 1"]
  c2 [label="Client 2"]
  c3 [label="Client 3"]
}
<% end %>

As discussed previously, we're trying to solve the problem of sending zeros and ones over the network between computers to allow them to communicate with each other to provide a shared multiplayer video game experience for two or more players over the internet.

A client-server architecture is built upon the principle of having one server communicate with several clients. There are many reasons why this architecture is favoured these days. The main one is that the game developers have full control over the server. They can provide a consistent online experience by ensuring that the servers are beefy enough and well connected enough to handle the demand of the game and by controlling the flow of data to make it harder for players to cheat. You wouldn't use a peer-to-peer architecture to to build Battle Royale FPS with 100 players on the map using a peer-to-peer architecture.

Briefly, let's talk about the difference between a dedicated server and a non dedicated server. A dedicated server is a server whose sole purpose is to conduct and run the simulation of the shared game world inhabited by the clients. A non dedicated server is a server which acts as a simulation of the shared world but also a graphical display, allowing one player to "host" a multiplayer game.  You'll notice that this kind of server was discussed in the peer-to-peer architecture section.

Some games allow for both dedicated servers and non dedicated servers. This requires more work but depending on the context, it could be worth the effort.

The dedicated server approach within a client-server architecture is the favoured method of implementation of online multiplayer play in today's AAA video game industry. It tends to be the most expensive of all possible implementations, however it is the best in terms of security and preventing players from cheating. And so, AAA video games using a client-server architecture with a solid anti-cheat solution have a higher likelyhood of being "fun" and can then profit through more purchases of the game and most likely micro transactions.

# MMORPGs?
I have no knowledge about how Massively Multiplayer Online Role Playing Games are built. What I can tell you is that they are the most complex online multiplayer games in existence. MMORPG developers have to painstakingly build network architectures from scratch in order to support the extreme number of players. Also, they must prevent cheating of any kind at all costs, otherwise cheats would break in-game progression systems and, more importantly, the in-game economy.

Games like EVE Online and WoW are good examples of this. Here's an [article from Gamasutra about the network architecture design in EVE Online](https://www.gamasutra.com/view/feature/132563/infinite_space_an_argument_for_.php?print=1) if you're interested in further reading on the topic of network architectures in MMORPGs.

# Conclusion
You now have the tools to understand, how the online multiplayer games you play, work behind the curtain. Alas, all good things must come to an end. I hope that this post was interesting and instructive. If you have any comments, feedback or thoughts on which topic you would like me to cover next, please [let me know](me@strategineer.com)!


