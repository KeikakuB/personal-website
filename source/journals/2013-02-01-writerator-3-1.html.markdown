---
title: Writerator Part III - Lessons Learned I
blog: journals
date: 2013-02-01
tags: projects
---
NB: This post is seperated into two parts due to its length. I learned a lot working on Writerator :), that's the way I like it.

In November, I read two programming books which changed the way I look at programming. The Art of UNIX Programming by Eric S. Raymond and The Pragmatic Programmer by Andrew Hunt both taught me about all the different aspects of programming (coding, design, best practices, etc.).

I mention them because they guided me in my development of Writerator and because some of the programming ideologies put forth by those two must-read books were reinforced by my experiences in the development of Writerator.

- Keep a notepad handy at all times (next to bed, computer)

When I work on a programming project, even when I'm not at my computer writing code, my mind always wanders back to thinking about what I can code next and how I can fix the problems I'm having.

For example, with Writerator, I thought that the time between me entering a command and receiving the result was too long. It was around 5 to 10 seconds (especially with big .txt files, ~3MB).

So, I ran a profiler on the code and saw that computing the data (lists of words, sentences and characters) for the input file was taking the majority of the time.

At first glance, I didn't know what to do. Computing the input data was costly and, in my mind, I thought that it was a necessary sacrifice. I was stuck. My head hurt from all the programming, so I went to sleep.

Early next morning, I woke up and thought, I should just precompute and store the data for each input file because unless the .txt file changes the data stays the same.

Then, I wrote it down, went back to sleep and implemented my lightbulb-idea-moment when I woke up. (The code for this feature can be found in the datastore.py module)

- Minimize code in main function/method using bite-sized and well-named functions

Making the main function of a program as small as possible is the first thing you should before sharing your code with the outside world. The main function assembles all the disparate pieces of your code into one unified whole.

If someone understands your main function then they understand your entire program. This is why it is important to keep your main function small, clear and concise.

Here's a cleaned up version of Writerator's main function as an example.
```
def main():
    #Runs Unit-Tests
    subprocess.call("python texttools_unittest.py -q")

    #Get configuration
    settings_config = configparser.ConfigParser()
    settings_config.read('config' + os.sep + 'settings.ini')
    batch_config = configparser.ConfigParser()
    batch_config.read('config' + os.sep + 'batch.ini')

    #Parse command line arguments
    parser = make_parser(settings_config)
    args = parser.parse_args()

    set_logging_level(args.debug)
    (filename_in, filename_out) = get_filenames(settings_config, args.file_in)
    text = Text(filename_in)

    output_lines = get_output(text, parser, batch_config)
    if args.output:
        output_to_file(filename_out, output_lines)
    else:
        output_to_console(output_lines)
```
Can you understand what it accomplishes at first glance? If so, I've done my job well.
